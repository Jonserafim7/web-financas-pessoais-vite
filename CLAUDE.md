# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

```bash
npm run dev              # Start dev server (http://0.0.0.0:5173)
npm run build            # Type-check and build for production
npm run lint             # Run ESLint
npm run preview          # Preview production build
npm run generate:api     # Generate API client from OpenAPI spec
```

## Architecture

### Tech Stack
- **React 19** with TypeScript
- **TanStack Router** for file-based routing with route protection
- **TanStack Query** for server state management
- **TanStack Form** for form state with Zod validation
- **Better Auth** for cookie-based authentication
- **Axios** for HTTP client with interceptors
- **Orval** to generate TypeScript API client from OpenAPI
- **Tailwind CSS v4** with Radix UI primitives
- **Vite** as build tool with React Compiler enabled

### Project Structure

```
src/
├── features/           # Feature-based modules
│   ├── auth/          # Authentication (Better Auth integration)
│   │   ├── components/
│   │   ├── hooks/     # React Query hooks (useSession, useSignIn, etc.)
│   │   └── query-keys.ts
│   └── transactions/  # Transaction management
│       └── components/
│           └── form/  # Form components with TanStack Form
├── routes/            # File-based routing (TanStack Router)
│   ├── __root.tsx
│   ├── _auth/         # Public auth routes
│   └── _protected/    # Protected routes (require session)
├── components/
│   └── ui/            # Reusable Radix UI components
├── lib/
│   ├── generated/     # Auto-generated by Orval (DO NOT EDIT)
│   │   ├── api/       # API functions by tags
│   │   └── models/    # TypeScript types from OpenAPI
│   ├── auth-client.ts # Better Auth client config
│   ├── api-client.ts  # Axios instance with interceptors
│   ├── query-client.ts
│   └── utils.ts
└── main.tsx
```

### Authentication Flow
- Uses **Better Auth** with cookie-based sessions
- Auth client configured with `basePath: "/auth"` and `credentials: "include"`
- Session loaded via `useSession()` hook before router initialization
- Protected routes use `_protected` layout that redirects to `/sign-in` if no session
- Axios interceptor redirects to `/login` on 401 responses

### API Client Generation
- Run `npm run generate:api` to regenerate API client from backend OpenAPI spec
- Backend must be running at `http://localhost:3000`
- Orval generates React Query hooks in `src/lib/generated/api/`
- Custom Axios instance in `src/lib/api-client.ts` handles auth cookies and error handling
- All generated files use custom mutator for consistent error handling

### Routing Patterns
- File-based routing in `src/routes/`
- `_auth` prefix for public authentication routes
- `_protected` prefix for routes requiring authentication
- Route context includes `queryClient` and `session`
- Protected route guard checks session from query cache via `authKeys.session`

### Form Handling
- TanStack Form with Zod validation via `validators.onBlur`
- Form schemas use generated types from `src/lib/generated/models/`
- Forms submit with `form.handleSubmit()` and pass values to mutation hooks
- Field validation displays errors on blur with `field.state.meta.isTouched`

### Development Server
- Vite dev server runs on `0.0.0.0:5173` (for Docker compatibility)
- Proxy configured: `/api` → `http://api:3000` (Docker service name)
- For local dev without Docker, update proxy target to `http://localhost:3000`

### Path Aliases
- `@/*` resolves to `src/*` (configured in tsconfig and vite.config)

### DevTools
- TanStack Devtools enabled with Query, Router, and Form panels
- React Compiler enabled (impacts dev/build performance)


These examples should be used as guidance when configuring Sentry functionality within a project.

# Error / Exception Tracking

Use `Sentry.captureException(error)` to capture an exception and log the error in Sentry.
Use this in try catch blocks or areas where exceptions are expected

# Tracing Examples

Spans should be created for meaningful actions within an applications like button clicks, API calls, and function calls
Ensure you are creating custom spans with meaningful names and operations
Use the `Sentry.startSpan` function to create a span
Child spans can exist within a parent span

## Custom Span instrumentation in component actions

```javascript
function TestComponent() {
  const handleTestButtonClick = () => {
    // Create a transaction/span to measure performance
    Sentry.startSpan(
      {
        op: "ui.click",
        name: "Test Button Click",
      },
      (span) => {
        const value = "some config";
        const metric = "some metric";

        // Metrics can be added to the span
        span.setAttribute("config", value);
        span.setAttribute("metric", metric);

        doSomething();
      },
    );
  };

  return (
    <button type="button" onClick={handleTestButtonClick}>
      Test Sentry
    </button>
  );
}
```

## Custom span instrumentation in API calls

```javascript
async function fetchUserData(userId) {
  return Sentry.startSpan(
    {
      op: "http.client",
      name: `GET /api/users/${userId}`,
    },
    async () => {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      return data;
    },
  );
}
```

# Logs

Where logs are used, ensure Sentry is imported using `import * as Sentry from "@sentry/react"`
Enable logging in Sentry using `Sentry.init({ enableLogs: true })`
Reference the logger using `const { logger } = Sentry`
Sentry offers a consoleLoggingIntegration that can be used to log specific console error types automatically without instrumenting the individual logger calls

## Configuration

### Baseline

```javascript
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: "https://f6082a98ad580f26220840d8f63c370f@o4510440027324416.ingest.us.sentry.io/4510440028241920",

  enableLogs: true,
});
```

### Logger Integration

```javascript
Sentry.init({
  dsn: "https://f6082a98ad580f26220840d8f63c370f@o4510440027324416.ingest.us.sentry.io/4510440028241920",
  integrations: [
    // send console.log, console.warn, and console.error calls as logs to Sentry
    Sentry.consoleLoggingIntegration({ levels: ["log", "warn", "error"] }),
  ],
});
```

## Logger Examples

`logger.fmt` is a template literal function that should be used to bring variables into the structured logs.

```javascript
logger.trace("Starting database connection", { database: "users" });
logger.debug(logger.fmt`Cache miss for user: ${userId}`);
logger.info("Updated profile", { profileId: 345 });
logger.warn("Rate limit reached for endpoint", {
  endpoint: "/api/results/",
  isEnterprise: false,
});
logger.error("Failed to process payment", {
  orderId: "order_123",
  amount: 99.99,
});
logger.fatal("Database connection pool exhausted", {
  database: "users",
  activeConnections: 100,
});
```

